
project bionic/
diff --git a/linker/debugger.cpp b/linker/debugger.cpp
index d4c7928..82f3261 100644
--- a/linker/debugger.cpp
+++ b/linker/debugger.cpp
@@ -259,6 +259,7 @@ static void send_debuggerd_packet(siginfo_t* info) {
  * Catches fatal signals so we can ask debuggerd to ptrace us before
  * we crash.
  */
+
 static void debuggerd_signal_handler(int signal_number, siginfo_t* info, void*) {
   // It's possible somebody cleared the SA_SIGINFO flag, which would mean
   // our "info" arg holds an undefined value.
@@ -270,32 +271,27 @@ static void debuggerd_signal_handler(int signal_number, siginfo_t* info, void*)
 
   send_debuggerd_packet(info);
 
-  // We need to return from the signal handler so that debuggerd can dump the
-  // thread that crashed, but returning here does not guarantee that the signal
-  // will be thrown again, even for SIGSEGV and friends, since the signal could
-  // have been sent manually. Resend the signal with rt_tgsigqueueinfo(2) to
-  // preserve the SA_SIGINFO contents.
+  // Remove our net so we fault for real when we return.
   signal(signal_number, SIG_DFL);
 
-  struct siginfo si;
-  if (!info) {
-    memset(&si, 0, sizeof(si));
-    si.si_code = SI_USER;
-    si.si_pid = getpid();
-    si.si_uid = getuid();
-    info = &si;
-  } else if (info->si_code >= 0 || info->si_code == SI_TKILL) {
-    // rt_tgsigqueueinfo(2)'s documentation appears to be incorrect on kernels
-    // that contain commit 66dd34a (3.9+). The manpage claims to only allow
-    // negative si_code values that are not SI_TKILL, but 66dd34a changed the
-    // check to allow all si_code values in calls coming from inside the house.
-  }
-
-  int rc = syscall(SYS_rt_tgsigqueueinfo, getpid(), gettid(), signal_number, info);
-  if (rc != 0) {
-    __libc_format_log(ANDROID_LOG_FATAL, "libc", "failed to resend signal during crash: %s",
-                      strerror(errno));
-    _exit(0);
+  // These signals are not re-thrown when we resume.  This means that
+  // crashing due to (say) SIGPIPE doesn't work the way you'd expect it
+  // to.  We work around this by throwing them manually.  We don't want
+  // to do this for *all* signals because it'll screw up the si_addr for
+  // faults like SIGSEGV. It does screw up the si_code, which is why we
+  // passed that to debuggerd above.
+  switch (signal_number) {
+    case SIGABRT:
+    case SIGFPE:
+    case SIGPIPE:
+#if defined(SIGSTKFLT)
+    case SIGSTKFLT:
+#endif
+    case SIGTRAP:
+      tgkill(getpid(), gettid(), signal_number);
+      break;
+    default:    // SIGILL, SIGBUS, SIGSEGV
+      break;
   }
 }
 

project build/
diff --git a/core/Makefile b/core/Makefile
index cb3ec9c..5902d1a 100644
--- a/core/Makefile
+++ b/core/Makefile
@@ -1098,9 +1098,9 @@ define build-recoveryimage-target
   )
   $(if $(filter true,$(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_SUPPORTS_VBOOT)), \
     $(VBOOT_SIGNER) $(FUTILITY) $(1).unsigned $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_VBOOT_SIGNING_KEY).vbpubk $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_VBOOT_SIGNING_KEY).vbprivk $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_VBOOT_SIGNING_SUBKEY).vbprivk $(1).keyblock $(1))
-  $(if $(filter true,$(BOARD_USES_RECOVERY_AS_BOOT)), \
-    $(hide) $(call assert-max-image-size,$(1),$(BOARD_BOOTIMAGE_PARTITION_SIZE)), \
-    $(hide) $(call assert-max-image-size,$(1),$(BOARD_RECOVERYIMAGE_PARTITION_SIZE)))
+#  $(if $(filter true,$(BOARD_USES_RECOVERY_AS_BOOT)), \
+#    $(hide) $(call assert-max-image-size,$(1),$(BOARD_BOOTIMAGE_PARTITION_SIZE)), \
+#    $(hide) $(call assert-max-image-size,$(1),$(BOARD_RECOVERYIMAGE_PARTITION_SIZE)))
   @echo "Made recovery image: $@"
 endef
 

project frameworks/base/
diff --git a/core/java/android/database/sqlite/SQLiteOpenHelper.java b/core/java/android/database/sqlite/SQLiteOpenHelper.java
index 2dd4800..dbe13b6 100644
--- a/core/java/android/database/sqlite/SQLiteOpenHelper.java
+++ b/core/java/android/database/sqlite/SQLiteOpenHelper.java
@@ -357,7 +357,7 @@ public abstract class SQLiteOpenHelper {
      * @param newVersion The new database version.
      */
     public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        throw new SQLiteException("Can't downgrade database from version " +
+        throw new SQLiteException("Can't downgrade database " + mContext.getDatabasePath(mName).getPath()  + " from version " +
                 oldVersion + " to " + newVersion);
     }
 

project frameworks/native/
diff --git a/include/ui/Gralloc1.h b/include/ui/Gralloc1.h
index cf8c173..10c484a 100644
--- a/include/ui/Gralloc1.h
+++ b/include/ui/Gralloc1.h
@@ -120,6 +120,8 @@ public:
 
     gralloc1_error_t unlock(buffer_handle_t buffer, sp<Fence>* outFence);
 
+    gralloc1_error_t getphys(buffer_handle_t buffer, void** paddr);
+
 private:
     std::unordered_set<gralloc1_capability_t> loadCapabilities();
 
@@ -208,6 +210,8 @@ private:
                 GRALLOC1_FUNCTION_LOCK_YCBCR> lockYCbCr;
         FunctionLoader<GRALLOC1_PFN_UNLOCK,
                 GRALLOC1_FUNCTION_UNLOCK> unlock;
+        FunctionLoader<GRALLOC1_PFN_GETPHYS,
+                GRALLOC1_FUNCTION_GETPHYS> getphys;
 
         // Adapter-only functions
         FunctionLoader<GRALLOC1_PFN_RETAIN_GRAPHIC_BUFFER,
diff --git a/include/ui/Gralloc1On0Adapter.h b/include/ui/Gralloc1On0Adapter.h
index 97c9a89..f6bd56b 100644
--- a/include/ui/Gralloc1On0Adapter.h
+++ b/include/ui/Gralloc1On0Adapter.h
@@ -459,6 +459,21 @@ private:
         return static_cast<int32_t>(error);
     }
 
+    gralloc1_error_t getphys(const std::shared_ptr<Buffer>& buffer,
+            void** paddr);
+    static int32_t getphysHook(gralloc1_device_t* device,
+            buffer_handle_t bufferHandle, void** paddr) {
+        auto adapter = getAdapter(device);
+
+        auto buffer = adapter->getBuffer(bufferHandle);
+        if (!buffer) {
+            return static_cast<int32_t>(GRALLOC1_ERROR_BAD_HANDLE);
+        }
+
+        auto error = adapter->getphys(buffer, paddr);
+        return static_cast<int32_t>(error);
+    }
+
     // Adapter internals
     const gralloc_module_t* mModule;
     uint8_t mMinorVersion;
diff --git a/libs/ui/Gralloc1.cpp b/libs/ui/Gralloc1.cpp
index 4c73ce4..9c34479 100644
--- a/libs/ui/Gralloc1.cpp
+++ b/libs/ui/Gralloc1.cpp
@@ -272,6 +272,12 @@ gralloc1_error_t Device::unlock(buffer_handle_t buffer, sp<Fence>* outFence)
     return error;
 }
 
+gralloc1_error_t Device::getphys(buffer_handle_t buffer, void** paddr){
+    int32_t intError = mFunctions.getphys(mDevice, buffer, paddr);
+    auto error = static_cast<gralloc1_error_t>(intError);
+    return error;
+}
+
 std::unordered_set<gralloc1_capability_t> Device::loadCapabilities()
 {
     std::vector<int32_t> intCapabilities;
@@ -348,6 +354,9 @@ bool Device::loadFunctions()
     if (!mFunctions.unlock.load(mDevice, true)) {
         return false;
     }
+    if (!mFunctions.getphys.load(mDevice, true)) {
+        return false;
+    }
 
     if (hasCapability(GRALLOC1_CAPABILITY_ON_ADAPTER)) {
         // These should always be present on the adapter
diff --git a/libs/ui/Gralloc1On0Adapter.cpp b/libs/ui/Gralloc1On0Adapter.cpp
index d5b88de..b8f4e0f 100644
--- a/libs/ui/Gralloc1On0Adapter.cpp
+++ b/libs/ui/Gralloc1On0Adapter.cpp
@@ -154,6 +154,8 @@ gralloc1_function_pointer_t Gralloc1On0Adapter::doGetFunction(
                     &Gralloc1On0Adapter::lockYCbCr>);
         case GRALLOC1_FUNCTION_UNLOCK:
             return asFP<GRALLOC1_PFN_UNLOCK>(unlockHook);
+        case GRALLOC1_FUNCTION_GETPHYS:
+            return asFP<GRALLOC1_PFN_GETPHYS>(getphysHook);
         case GRALLOC1_FUNCTION_INVALID:
             ALOGE("Invalid function descriptor");
             return nullptr;
@@ -450,6 +452,20 @@ gralloc1_error_t Gralloc1On0Adapter::unlock(
     return GRALLOC1_ERROR_NONE;
 }
 
+gralloc1_error_t Gralloc1On0Adapter::getphys(const std::shared_ptr<Buffer>& buffer,
+                    void** paddr)
+{
+  int err = mModule->getphys(mModule, buffer->getHandle(), paddr);
+  ALOGW_IF(err, "getphys(%p) fail %d(%s)", buffer->getHandle(), err, strerror(-err));
+  ALOGD("Gralloc1On0Adapter::getphys");
+  if(err){
+    return GRALLOC1_ERROR_NO_RESOURCES;
+  }else{
+    return GRALLOC1_ERROR_NONE;
+  }
+}
+
+
 std::shared_ptr<Gralloc1On0Adapter::Descriptor>
 Gralloc1On0Adapter::getDescriptor(gralloc1_buffer_descriptor_t descriptorId)
 {
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index aa14caa..c42cd68 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -290,9 +290,8 @@ status_t GraphicBufferMapper::unlockAsync(buffer_handle_t handle, int *fenceFd)
 #ifdef EXYNOS4_ENHANCEMENTS
 status_t GraphicBufferMapper::getphys(buffer_handle_t handle, void** paddr)
 {
-    status_t err;
-
-    err = mAllocMod->getphys(mAllocMod, handle, paddr);
+    gralloc1_error_t err = mDevice->getphys(handle, paddr);
+    ALOGD("GraphicBufferMapper::getphys");
 
     ALOGW_IF(err, "getphys(%p) fail %d(%s)", handle, err, strerror(-err));
     return err;
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 97b727b..68e4171 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -152,6 +152,13 @@ public:
         return *mRenderEngine;
     }
 
+    class LayerVector : public SortedVector< sp<Layer> > {
+    public:
+        LayerVector();
+        LayerVector(const LayerVector& rhs);
+        virtual int do_compare(const void* lhs, const void* rhs) const;
+    };
+
 private:
     friend class Client;
     friend class DisplayEventConnection;
@@ -173,12 +180,6 @@ private:
      * Internal data structures
      */
 
-    class LayerVector : public SortedVector< sp<Layer> > {
-    public:
-        LayerVector();
-        LayerVector(const LayerVector& rhs);
-        virtual int do_compare(const void* lhs, const void* rhs) const;
-    };
 
     struct DisplayDeviceState {
         DisplayDeviceState();
diff --git a/services/surfaceflinger/SurfaceFlinger.h.orig b/services/surfaceflinger/SurfaceFlinger.h.orig
new file mode 100644
index 0000000..97b727b
--- /dev/null
+++ b/services/surfaceflinger/SurfaceFlinger.h.orig
@@ -0,0 +1,663 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SURFACE_FLINGER_H
+#define ANDROID_SURFACE_FLINGER_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <EGL/egl.h>
+
+/*
+ * NOTE: Make sure this file doesn't include  anything from <gl/ > or <gl2/ >
+ */
+
+#include <cutils/compiler.h>
+
+#include <utils/Atomic.h>
+#include <utils/Errors.h>
+#include <utils/KeyedVector.h>
+#include <utils/RefBase.h>
+#include <utils/SortedVector.h>
+#include <utils/threads.h>
+
+#include <binder/IMemory.h>
+
+#include <ui/PixelFormat.h>
+#include <ui/mat4.h>
+
+#include <gui/ISurfaceComposer.h>
+#include <gui/ISurfaceComposerClient.h>
+#include <gui/OccupancyTracker.h>
+
+#include <hardware/hwcomposer_defs.h>
+
+#include <system/graphics.h>
+
+#include <private/gui/LayerState.h>
+
+#include "Barrier.h"
+#include "DisplayDevice.h"
+#include "DispSync.h"
+#include "FenceTracker.h"
+#include "FrameTracker.h"
+#include "MessageQueue.h"
+
+#include "DisplayHardware/HWComposer.h"
+#include "Effects/Daltonizer.h"
+
+#include "FrameRateHelper.h"
+
+#include <map>
+#include <string>
+
+namespace android {
+
+// ---------------------------------------------------------------------------
+
+class Client;
+class DisplayEventConnection;
+class EventThread;
+class IGraphicBufferAlloc;
+class Layer;
+class LayerDim;
+class LayerBlur;
+class Surface;
+class RenderEngine;
+class EventControlThread;
+
+// ---------------------------------------------------------------------------
+
+enum {
+    eTransactionNeeded        = 0x01,
+    eTraversalNeeded          = 0x02,
+    eDisplayTransactionNeeded = 0x04,
+    eTransactionMask          = 0x07
+};
+
+class SurfaceFlinger : public BnSurfaceComposer,
+                       private IBinder::DeathRecipient,
+                       private HWComposer::EventHandler
+{
+public:
+#ifdef QTI_BSP
+    friend class ExSurfaceFlinger;
+#endif
+
+    static char const* getServiceName() ANDROID_API {
+        return "SurfaceFlinger";
+    }
+
+    SurfaceFlinger() ANDROID_API;
+
+    // must be called before clients can connect
+    void init() ANDROID_API;
+
+    // starts SurfaceFlinger main loop in the current thread
+    void run() ANDROID_API;
+
+    enum {
+        EVENT_VSYNC = HWC_EVENT_VSYNC
+    };
+
+    // post an asynchronous message to the main thread
+    status_t postMessageAsync(const sp<MessageBase>& msg, nsecs_t reltime = 0, uint32_t flags = 0);
+
+    // post a synchronous message to the main thread
+    status_t postMessageSync(const sp<MessageBase>& msg, nsecs_t reltime = 0, uint32_t flags = 0);
+
+    // force full composition on all displays
+    void repaintEverything();
+
+    // returns the default Display
+    sp<const DisplayDevice> getDefaultDisplayDevice() const {
+        return getDisplayDevice(mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY]);
+    }
+
+    // utility function to delete a texture on the main thread
+    void deleteTextureAsync(uint32_t texture);
+
+    // enable/disable h/w composer event
+    // TODO: this should be made accessible only to EventThread
+#ifdef USE_HWC2
+    void setVsyncEnabled(int disp, int enabled);
+#else
+    void eventControl(int disp, int event, int enabled);
+#endif
+
+    // called on the main thread by MessageQueue when an internal message
+    // is received
+    // TODO: this should be made accessible only to MessageQueue
+    void onMessageReceived(int32_t what);
+
+    // for debugging only
+    // TODO: this should be made accessible only to HWComposer
+    const Vector< sp<Layer> >& getLayerSortedByZForHwcDisplay(int id);
+
+    RenderEngine& getRenderEngine() const {
+        return *mRenderEngine;
+    }
+
+private:
+    friend class Client;
+    friend class DisplayEventConnection;
+    friend class Layer;
+    friend class LayerDim;
+    friend class MonitoredProducer;
+    friend class LayerBlur;
+
+    // This value is specified in number of frames.  Log frame stats at most
+    // every half hour.
+    enum { LOG_FRAME_STATS_PERIOD =  30*60*60 };
+
+    static const size_t MAX_LAYERS = 4096;
+
+    // We're reference counted, never destroy SurfaceFlinger directly
+    virtual ~SurfaceFlinger();
+
+    /* ------------------------------------------------------------------------
+     * Internal data structures
+     */
+
+    class LayerVector : public SortedVector< sp<Layer> > {
+    public:
+        LayerVector();
+        LayerVector(const LayerVector& rhs);
+        virtual int do_compare(const void* lhs, const void* rhs) const;
+    };
+
+    struct DisplayDeviceState {
+        DisplayDeviceState();
+        DisplayDeviceState(DisplayDevice::DisplayType type, bool isSecure);
+        bool isValid() const { return type >= 0; }
+        bool isMainDisplay() const { return type == DisplayDevice::DISPLAY_PRIMARY; }
+        bool isVirtualDisplay() const { return type >= DisplayDevice::DISPLAY_VIRTUAL; }
+        DisplayDevice::DisplayType type;
+        sp<IGraphicBufferProducer> surface;
+        uint32_t layerStack;
+        Rect viewport;
+        Rect frame;
+        uint8_t orientation;
+        uint32_t width, height;
+        String8 displayName;
+        bool isSecure;
+    };
+
+    struct State {
+        LayerVector layersSortedByZ;
+        DefaultKeyedVector< wp<IBinder>, DisplayDeviceState> displays;
+    };
+
+    /* ------------------------------------------------------------------------
+     * IBinder interface
+     */
+    virtual status_t onTransact(uint32_t code, const Parcel& data,
+        Parcel* reply, uint32_t flags);
+    virtual status_t dump(int fd, const Vector<String16>& args);
+
+    /* ------------------------------------------------------------------------
+     * ISurfaceComposer interface
+     */
+    virtual sp<ISurfaceComposerClient> createConnection();
+    virtual sp<IGraphicBufferAlloc> createGraphicBufferAlloc();
+    virtual sp<IBinder> createDisplay(const String8& displayName, bool secure);
+    virtual void destroyDisplay(const sp<IBinder>& display);
+    virtual sp<IBinder> getBuiltInDisplay(int32_t id);
+    virtual void setTransactionState(const Vector<ComposerState>& state,
+            const Vector<DisplayState>& displays, uint32_t flags);
+    virtual void bootFinished();
+    virtual bool authenticateSurfaceTexture(
+        const sp<IGraphicBufferProducer>& bufferProducer) const;
+    virtual sp<IDisplayEventConnection> createDisplayEventConnection();
+    virtual status_t captureScreen(const sp<IBinder>& display,
+            const sp<IGraphicBufferProducer>& producer,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform, ISurfaceComposer::Rotation rotation,
+            bool isCpuConsumer);
+    virtual status_t getDisplayStats(const sp<IBinder>& display,
+            DisplayStatInfo* stats);
+    virtual status_t getDisplayConfigs(const sp<IBinder>& display,
+            Vector<DisplayInfo>* configs);
+    virtual int getActiveConfig(const sp<IBinder>& display);
+    virtual status_t getDisplayColorModes(const sp<IBinder>& display,
+            Vector<android_color_mode_t>* configs);
+    virtual android_color_mode_t getActiveColorMode(const sp<IBinder>& display);
+    virtual status_t setActiveColorMode(const sp<IBinder>& display, android_color_mode_t colorMode);
+    virtual void setPowerMode(const sp<IBinder>& display, int mode);
+    virtual status_t setActiveConfig(const sp<IBinder>& display, int id);
+    virtual status_t clearAnimationFrameStats();
+    virtual status_t getAnimationFrameStats(FrameStats* outStats) const;
+    virtual status_t getHdrCapabilities(const sp<IBinder>& display,
+            HdrCapabilities* outCapabilities) const;
+
+    /* ------------------------------------------------------------------------
+     * DeathRecipient interface
+     */
+    virtual void binderDied(const wp<IBinder>& who);
+
+    /* ------------------------------------------------------------------------
+     * RefBase interface
+     */
+    virtual void onFirstRef();
+
+    /* ------------------------------------------------------------------------
+     * HWComposer::EventHandler interface
+     */
+    virtual void onVSyncReceived(int type, nsecs_t timestamp);
+    virtual void onHotplugReceived(int disp, bool connected);
+
+    /* ------------------------------------------------------------------------
+     * Extensions
+     */
+    virtual void updateExtendedMode() { }
+
+    virtual void getIndexLOI(size_t /*dpy*/,
+                     const LayerVector& /*currentLayers*/,
+                     bool& /*bIgnoreLayers*/,
+                     int& /*indexLOI*/) { }
+
+#ifndef USE_HWC2
+    virtual bool updateLayerVisibleNonTransparentRegion(
+                     const int& dpy, const sp<Layer>& layer,
+                     bool& bIgnoreLayers, int& indexLOI,
+                     uint32_t layerStack, const int& i);
+
+    virtual void delayDPTransactionIfNeeded(
+                     const Vector<DisplayState>& /*displays*/) { }
+
+    virtual bool canDrawLayerinScreenShot(
+                     const sp<const DisplayDevice>& hw,
+                     const sp<Layer>& layer);
+
+    virtual void isfreezeSurfacePresent(
+                     bool& freezeSurfacePresent,
+                     const sp<const DisplayDevice>& /*hw*/,
+                     const int32_t& /*id*/) { freezeSurfacePresent = false; }
+
+    virtual void setOrientationEventControl(
+                     bool& /*freezeSurfacePresent*/,
+                     const int32_t& /*id*/) { }
+
+    virtual void updateVisibleRegionsDirty() { }
+
+    virtual void  drawWormHoleIfRequired(HWComposer::LayerListIterator &cur,
+        const HWComposer::LayerListIterator &end,
+        const sp<const DisplayDevice>& hw,
+        const Region& region);
+#endif
+    virtual bool isS3DLayerPresent(const sp<const DisplayDevice>& /*hw*/)
+        { return false; };
+    /* ------------------------------------------------------------------------
+     * Message handling
+     */
+    void waitForEvent();
+    void signalTransaction();
+    void signalLayerUpdate();
+    void signalRefresh();
+
+    // called on the main thread in response to initializeDisplays()
+    void onInitializeDisplays();
+    // called on the main thread in response to setActiveConfig()
+    void setActiveConfigInternal(const sp<DisplayDevice>& hw, int mode);
+    // called on the main thread in response to setPowerMode()
+    void setPowerModeInternal(const sp<DisplayDevice>& hw, int mode);
+
+    // Called on the main thread in response to setActiveColorMode()
+    void setActiveColorModeInternal(const sp<DisplayDevice>& hw, android_color_mode_t colorMode);
+
+    // Returns whether the transaction actually modified any state
+    bool handleMessageTransaction();
+
+    // Returns whether a new buffer has been latched (see handlePageFlip())
+    bool handleMessageInvalidate();
+
+    void handleMessageRefresh();
+
+    void handleTransaction(uint32_t transactionFlags);
+    void handleTransactionLocked(uint32_t transactionFlags);
+
+    void updateCursorAsync();
+
+    /* handlePageFlip - latch a new buffer if available and compute the dirty
+     * region. Returns whether a new buffer has been latched, i.e., whether it
+     * is necessary to perform a refresh during this vsync.
+     */
+    bool handlePageFlip();
+
+    /* ------------------------------------------------------------------------
+     * Transactions
+     */
+    uint32_t getTransactionFlags(uint32_t flags);
+    uint32_t peekTransactionFlags(uint32_t flags);
+    uint32_t setTransactionFlags(uint32_t flags);
+    void commitTransaction();
+    uint32_t setClientStateLocked(const sp<Client>& client, const layer_state_t& s);
+    uint32_t setDisplayStateLocked(const DisplayState& s);
+
+    /* ------------------------------------------------------------------------
+     * Layer management
+     */
+    status_t createLayer(const String8& name, const sp<Client>& client,
+            uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
+            sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp);
+
+    status_t createNormalLayer(const sp<Client>& client, const String8& name,
+            uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
+            sp<IBinder>* outHandle, sp<IGraphicBufferProducer>* outGbp,
+            sp<Layer>* outLayer);
+
+    status_t createDimLayer(const sp<Client>& client, const String8& name,
+            uint32_t w, uint32_t h, uint32_t flags, sp<IBinder>* outHandle,
+            sp<IGraphicBufferProducer>* outGbp, sp<Layer>* outLayer);
+
+    status_t createBlurLayer(const sp<Client>& client, const String8& name,
+            uint32_t w, uint32_t h, uint32_t flags, sp<IBinder>* outHandle,
+            sp<IGraphicBufferProducer>* outGbp, sp<Layer>* outLayer);
+
+    // called in response to the window-manager calling
+    // ISurfaceComposerClient::destroySurface()
+    status_t onLayerRemoved(const sp<Client>& client, const sp<IBinder>& handle);
+
+    // called when all clients have released all their references to
+    // this layer meaning it is entirely safe to destroy all
+    // resources associated to this layer.
+    status_t onLayerDestroyed(const wp<Layer>& layer);
+
+    // remove a layer from SurfaceFlinger immediately
+    status_t removeLayer(const wp<Layer>& layer);
+
+    // add a layer to SurfaceFlinger
+    status_t addClientLayer(const sp<Client>& client,
+            const sp<IBinder>& handle,
+            const sp<IGraphicBufferProducer>& gbc,
+            const sp<Layer>& lbc);
+
+    /* ------------------------------------------------------------------------
+     * Boot animation, on/off animations and screen capture
+     */
+
+    void startBootAnim();
+
+    void renderScreenImplLocked(
+            const sp<const DisplayDevice>& hw,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool yswap, bool useIdentityTransform, Transform::orientation_flags rotation);
+
+    status_t captureScreenImplLocked(
+            const sp<const DisplayDevice>& hw,
+            const sp<IGraphicBufferProducer>& producer,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform, Transform::orientation_flags rotation,
+            bool isLocalScreenshot, bool useReadPixels);
+
+    /* ------------------------------------------------------------------------
+     * EGL
+     */
+    size_t getMaxTextureSize() const;
+    size_t getMaxViewportDims() const;
+
+    /* ------------------------------------------------------------------------
+     * Display and layer stack management
+     */
+    // called when starting, or restarting after system_server death
+    void initializeDisplays();
+
+    // Create an IBinder for a builtin display and add it to current state
+    void createBuiltinDisplayLocked(DisplayDevice::DisplayType type);
+
+    // NOTE: can only be called from the main thread or with mStateLock held
+    sp<const DisplayDevice> getDisplayDevice(const wp<IBinder>& dpy) const {
+        return mDisplays.valueFor(dpy);
+    }
+
+    // NOTE: can only be called from the main thread or with mStateLock held
+    sp<DisplayDevice> getDisplayDevice(const wp<IBinder>& dpy) {
+        return mDisplays.valueFor(dpy);
+    }
+
+    int32_t getDisplayType(const sp<IBinder>& display) {
+        if (!display.get()) return NAME_NOT_FOUND;
+        for (int i = 0; i < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; ++i) {
+            if (display == mBuiltinDisplays[i]) {
+                return i;
+            }
+        }
+        return NAME_NOT_FOUND;
+    }
+
+    // mark a region of a layer stack dirty. this updates the dirty
+    // region of all screens presenting this layer stack.
+    void invalidateLayerStack(uint32_t layerStack, const Region& dirty);
+
+#ifndef USE_HWC2
+    int32_t allocateHwcDisplayId(DisplayDevice::DisplayType type);
+#endif
+
+    /* ------------------------------------------------------------------------
+     * H/W composer
+     */
+
+    HWComposer& getHwComposer() const { return *mHwc; }
+
+    /* ------------------------------------------------------------------------
+     * Compositing
+     */
+    void invalidateHwcGeometry();
+    void computeVisibleRegions(size_t dpy,
+            const LayerVector& currentLayers, uint32_t layerStack,
+            Region& dirtyRegion, Region& opaqueRegion);
+
+    void preComposition();
+    void postComposition(nsecs_t refreshStartTime);
+    void rebuildLayerStacks();
+    void setUpHWComposer();
+    void doComposition();
+    void doDebugFlashRegions();
+    void doDisplayComposition(const sp<const DisplayDevice>& hw, const Region& dirtyRegion);
+
+    // compose surfaces for display hw. this fails if using GL and the surface
+    // has been destroyed and is no longer valid.
+    bool doComposeSurfaces(const sp<const DisplayDevice>& hw, const Region& dirty);
+
+    void postFramebuffer();
+    void drawWormhole(const sp<const DisplayDevice>& hw, const Region& region) const;
+
+    /* ------------------------------------------------------------------------
+     * Display management
+     */
+
+    /* ------------------------------------------------------------------------
+     * VSync
+     */
+     void enableHardwareVsync();
+     void resyncToHardwareVsync(bool makeAvailable);
+     void disableHardwareVsync(bool makeUnavailable);
+public:
+     void resyncWithRateLimit();
+private:
+
+    /* ------------------------------------------------------------------------
+     * Debugging & dumpsys
+     */
+    void listLayersLocked(const Vector<String16>& args, size_t& index, String8& result) const;
+    void dumpStatsLocked(const Vector<String16>& args, size_t& index, String8& result) const;
+    void clearStatsLocked(const Vector<String16>& args, size_t& index, String8& result);
+    void dumpAllLocked(const Vector<String16>& args, size_t& index, String8& result) const;
+    bool startDdmConnection();
+    static void appendSfConfigString(String8& result);
+    void checkScreenshot(size_t w, size_t s, size_t h, void const* vaddr,
+            const sp<const DisplayDevice>& hw,
+            uint32_t minLayerZ, uint32_t maxLayerZ);
+
+    void logFrameStats();
+
+    void dumpStaticScreenStats(String8& result) const;
+    virtual void dumpDrawCycle(bool /* prePrepare */ ) { }
+
+    void recordBufferingStats(const char* layerName,
+            std::vector<OccupancyTracker::Segment>&& history);
+    void dumpBufferingStats(String8& result) const;
+
+    bool getFrameTimestamps(const Layer& layer, uint64_t frameNumber,
+            FrameTimestamps* outTimestamps);
+
+    /* ------------------------------------------------------------------------
+     * Attributes
+     */
+
+    // access must be protected by mStateLock
+    mutable Mutex mStateLock;
+    State mCurrentState;
+    volatile int32_t mTransactionFlags;
+    Condition mTransactionCV;
+    bool mTransactionPending;
+    bool mAnimTransactionPending;
+    Vector< sp<Layer> > mLayersPendingRemoval;
+    SortedVector< wp<IBinder> > mGraphicBufferProducerList;
+
+    // protected by mStateLock (but we could use another lock)
+    bool mLayersRemoved;
+
+    // access must be protected by mInvalidateLock
+    volatile int32_t mRepaintEverything;
+
+    // constant members (no synchronization needed for access)
+    HWComposer* mHwc;
+    RenderEngine* mRenderEngine;
+    nsecs_t mBootTime;
+    bool mGpuToCpuSupported;
+    sp<EventThread> mEventThread;
+    sp<EventThread> mSFEventThread;
+    sp<EventControlThread> mEventControlThread;
+    EGLContext mEGLContext;
+    EGLDisplay mEGLDisplay;
+    sp<IBinder> mBuiltinDisplays[DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES];
+
+    // Can only accessed from the main thread, these members
+    // don't need synchronization
+    State mDrawingState;
+    bool mVisibleRegionsDirty;
+#ifndef USE_HWC2
+    bool mHwWorkListDirty;
+#else
+    bool mGeometryInvalid;
+#endif
+    bool mAnimCompositionPending;
+#ifdef USE_HWC2
+    std::vector<sp<Layer>> mLayersWithQueuedFrames;
+    sp<Fence> mPreviousPresentFence = Fence::NO_FENCE;
+    bool mHadClientComposition = false;
+#endif
+
+    // this may only be written from the main thread with mStateLock held
+    // it may be read from other threads with mStateLock held
+    DefaultKeyedVector< wp<IBinder>, sp<DisplayDevice> > mDisplays;
+
+    // don't use a lock for these, we don't care
+    int mDebugRegion;
+    int mDebugDDMS;
+    int mDebugDisableHWC;
+    int mDebugDisableTransformHint;
+    volatile nsecs_t mDebugInSwapBuffers;
+    nsecs_t mLastSwapBufferTime;
+    volatile nsecs_t mDebugInTransaction;
+    nsecs_t mLastTransactionTime;
+    bool mBootFinished;
+    bool mForceFullDamage;
+    FenceTracker mFenceTracker;
+#ifdef USE_HWC2
+    bool mPropagateBackpressure = true;
+#endif
+    bool mUseHwcVirtualDisplays = true;
+
+    // these are thread safe
+    mutable MessageQueue mEventQueue;
+    FrameTracker mAnimFrameTracker;
+    DispSync mPrimaryDispSync;
+
+    // protected by mDestroyedLayerLock;
+    mutable Mutex mDestroyedLayerLock;
+    Vector<Layer const *> mDestroyedLayers;
+
+    // protected by mHWVsyncLock
+    Mutex mHWVsyncLock;
+    bool mPrimaryHWVsyncEnabled;
+    bool mHWVsyncAvailable;
+
+    /* ------------------------------------------------------------------------
+     * Feature prototyping
+     */
+
+    Daltonizer mDaltonizer;
+#ifndef USE_HWC2
+    bool mDaltonize;
+#endif
+
+    mat4 mPreviousColorMatrix;
+    mat4 mColorMatrix;
+    bool mHasColorMatrix;
+
+    mat4 mSecondaryColorMatrix;
+    bool mHasSecondaryColorMatrix;
+
+    // Static screen stats
+    bool mHasPoweredOff;
+    static const size_t NUM_BUCKETS = 8; // < 1-7, 7+
+    nsecs_t mFrameBuckets[NUM_BUCKETS];
+    nsecs_t mTotalTime;
+    std::atomic<nsecs_t> mLastSwapTime;
+
+    FrameRateHelper mFrameRateHelper;
+
+    /*
+     * A number that increases on every new frame composition and screen capture.
+     * LayerBlur can speed up it's drawing by caching texture using this variable
+     * if multiple LayerBlur objects draw in one frame composition.
+     * In case of display mirroring, this variable should be increased on every display.
+     */
+    uint32_t mActiveFrameSequence;
+
+    // Double- vs. triple-buffering stats
+    struct BufferingStats {
+        BufferingStats()
+          : numSegments(0),
+            totalTime(0),
+            twoBufferTime(0),
+            doubleBufferedTime(0),
+            tripleBufferedTime(0) {}
+
+        size_t numSegments;
+        nsecs_t totalTime;
+
+        // "Two buffer" means that a third buffer was never used, whereas
+        // "double-buffered" means that on average the segment only used two
+        // buffers (though it may have used a third for some part of the
+        // segment)
+        nsecs_t twoBufferTime;
+        nsecs_t doubleBufferedTime;
+        nsecs_t tripleBufferedTime;
+    };
+    mutable Mutex mBufferingStatsMutex;
+    std::unordered_map<std::string, BufferingStats> mBufferingStats;
+};
+
+}; // namespace android
+
+#endif // ANDROID_SURFACE_FLINGER_H

project hardware/libhardware/
diff --git a/include/hardware/gps.h b/include/hardware/gps.h
index acf601b..42551de 100644
--- a/include/hardware/gps.h
+++ b/include/hardware/gps.h
@@ -670,6 +670,10 @@ typedef struct {
     uint16_t tac;
     /** Physical Cell id in LTE (not used in 2G and 3G) */
     uint16_t pcid;
+//#ifdef AGPS_USE_PSC
+    uint16_t psc;
+//#endif
+
 } AGpsRefLocationCellID;
 
 typedef struct {
diff --git a/include/hardware/gralloc1.h b/include/hardware/gralloc1.h
index 58c0e33..cf735f9 100644
--- a/include/hardware/gralloc1.h
+++ b/include/hardware/gralloc1.h
@@ -141,7 +141,8 @@ typedef enum {
     GRALLOC1_FUNCTION_LOCK = 18,
     GRALLOC1_FUNCTION_LOCK_FLEX = 19,
     GRALLOC1_FUNCTION_UNLOCK = 20,
-    GRALLOC1_LAST_FUNCTION = 20,
+    GRALLOC1_FUNCTION_GETPHYS = 21,
+    GRALLOC1_LAST_FUNCTION = 21,
 } gralloc1_function_descriptor_t;
 
 typedef enum {
@@ -882,6 +883,10 @@ typedef int32_t /*gralloc1_error_t*/ (*GRALLOC1_PFN_UNLOCK)(
         gralloc1_device_t* device, buffer_handle_t buffer,
         int32_t* outReleaseFence);
 
+typedef int32_t /*gralloc1_error_t*/ (*GRALLOC1_PFN_GETPHYS)(
+        gralloc1_device_t* device, buffer_handle_t buffer,
+        void** paddr);
+
 __END_DECLS
 
 #endif

project prebuilts/sdk/
diff --git a/tools/jack-admin b/tools/jack-admin
index ee193fc..40202aa 100755
--- a/tools/jack-admin
+++ b/tools/jack-admin
@@ -26,7 +26,7 @@ umask 077
 JACK_HOME="${JACK_HOME:=$HOME/.jack-server}"
 CLIENT_SETTING="${CLIENT_SETTING:=$HOME/.jack-settings}"
 TMPDIR=${TMPDIR:=/tmp}
-JACK_SERVER_VM_ARGUMENTS="${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding=UTF-8 -XX:+TieredCompilation}"
+JACK_SERVER_VM_ARGUMENTS="${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding=UTF-8 -XX:+TieredCompilation} -Xmx4096m"
 JACK_EXTRA_CURL_OPTIONS=${JACK_EXTRA_CURL_OPTIONS:=}
 
 LAUNCHER_JAR="$JACK_HOME/launcher.jar"

project system/vold/
diff --git a/cryptfs.c b/cryptfs.c
index 85c37b9..b294382 100644
--- a/cryptfs.c
+++ b/cryptfs.c
@@ -4223,6 +4223,7 @@ int cryptfs_enable_file()
 int cryptfs_isConvertibleToFBE()
 {
     struct fstab_rec* rec = fs_mgr_get_entry_for_mount_point(fstab, DATA_MNT_POINT);
+    if(!rec)return 0;
     return fs_mgr_is_convertible_to_fbe(rec) ? 1 : 0;
 }
 
